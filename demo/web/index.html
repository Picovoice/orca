<!DOCTYPE html>
<html lang="en">
<head>
  <script src="node_modules/@picovoice/orca-web/dist/iife/index.js"></script>
  <script type="application/javascript" src="orca_params_female.js"></script>
  <script type="application/javascript">
    const ORCA_SAMPLE_RATE = 22050;

    let orca = null;
    let pcm = null;
    let alignments = null;
    let orcaStream = null;
    let streamPcm = [];

    function writeMessage(message) {
      console.log(message);
      document.getElementById('status').innerText = message;
    }

    window.onload = function() {
      const audioContext = new (window.AudioContext ||
        window.webKitAudioContext)({ sampleRate: ORCA_SAMPLE_RATE });

      const originalAudioGain = audioContext.createGain();
      originalAudioGain.gain.value = 1;
      originalAudioGain.connect(audioContext.destination);

      function createBuffer(data) {
        const buffer = audioContext.createBuffer(
          1,
          data.length,
          ORCA_SAMPLE_RATE,
        );
        const source = new Float32Array(data.length);
        for (let i = 0; i < data.length; i++) {
          source[i] = data[i] < 0 ? data[i] / 32768 : data[i] / 32767;
        }
        buffer.copyToChannel(source, 0);
        return buffer;
      }

      let isPlaying = false;
      let originalAudioSource;

      // Choose mode
      const choiceBtnsEl = document.getElementById('choice-btns');
      const chooseStreamingBtnEl = document.getElementById('choose-streaming-btn');
      const chooseSingleBtnEl = document.getElementById('choose-single-btn');
      const streamingSynthesisEl = document.getElementById('streaming-synthesis');
      const singleSynthesisEl = document.getElementById('single-synthesis');

      chooseStreamingBtnEl.addEventListener('click', () => {
        choiceBtnsEl.style.display = 'none';
        streamingSynthesisEl.style.display = 'block';
        writeMessage('Streaming synthesis selected!');
      });

      chooseSingleBtnEl.addEventListener('click', () => {
        choiceBtnsEl.style.display = 'none';
        singleSynthesisEl.style.display = 'block';
        writeMessage('Single synthesis selected!');
      });

      // Streaming synthesis controls
      const speechRateSliderStreamEl = document.getElementById('speech-rate-stream');
      const speechRateDisplayStreamEl = document.getElementById('speech-rate-stream-display');
      const streamOpenBtnEl = document.getElementById('stream-open');
      const textToSynthesizeStreamEl = document.getElementById('text-to-synthesize-stream');
      const textToSynthesizeErrorStreamEl = document.getElementById('text-to-synthesize-stream-error');
      const streamFlushBtnEl = document.getElementById('stream-flush');
      const downloadBtnStreamEl = document.getElementById('download-stream-btn');

      function synthesizeCallback(synthesizeResult) {
        if (synthesizeResult.pcm.length > 0) {
          originalAudioSource = audioContext.createBufferSource();
          originalAudioSource.buffer = createBuffer(synthesizeResult.pcm);
          originalAudioSource.connect(originalAudioGain);
          originalAudioSource.start();
          streamPcm.push(...synthesizeResult.pcm);
        }
      }

      async function streamOpen() {
        writeMessage('Opening stream. Please wait...');
        try {
          document.getElementById('start-orca').disabled = true;
          textToSynthesizeStreamEl.disabled = true;
          speechRateSliderStreamEl.disabled = true;
          streamOpenBtnEl.disabled = true;
          const speechRate = speechRateSliderStreamEl.value;

          orcaStream = await orca.streamOpen(
            synthesizeCallback,
            { synthesizeParams: { speechRate } },
          );

          textToSynthesizeStreamEl.disabled = false;

          let previousValue = '';
          textToSynthesizeStreamEl.addEventListener('input', async (e) => {
            const currentValue = e.target.value;
            const addedText = currentValue.substring(previousValue.length);
            const isValidInput = validateInput(addedText, orca.validCharacters);
            if (isValidInput) {
              await orcaStream.synthesize(addedText);
              previousValue = currentValue;
              streamFlushBtnEl.disabled = false;
              downloadBtnStreamEl.disabled = false;
            }
          });

          writeMessage('Orca stream open! Start typing to synthesize speech. Click "Flush" when done.');
        } catch (err) {
          writeMessage(err);
        }
      }

      async function streamFlush() {
        await orcaStream.flush();
      }

      speechRateSliderStreamEl.addEventListener('change', () =>
        speechRateDisplayStreamEl.innerText = speechRateSliderStreamEl.value,
      );
      streamOpenBtnEl.addEventListener('click', streamOpen);
      streamFlushBtnEl.addEventListener('click', streamFlush);

      // Single synthesis controls
      const textToSynthesizeEl = document.getElementById('text-to-synthesize');
      const textToSynthesizeErrorEl = document.getElementById('text-to-synthesize-error');
      const speechRateSliderEl = document.getElementById('speech-rate');
      const synthesizeBtnEl = document.getElementById('synthesize-btn');
      const controlBtnEl = document.getElementById('control-btn');
      const downloadBtnEl = document.getElementById('download-btn');
      const speechRateDisplayEl = document.getElementById('speech-rate-display');
      const alignmentsTableEl = document.getElementById('alignments-table');

      function onSynthesizeParamChange() {
        if (orca !== null && isPlaying === false) {
          synthesizeBtnEl.disabled = false;
          controlBtnEl.disabled = true;
          downloadBtnEl.disabled = true;
          controlBtnEl.innerText = 'Play';
        }
      }

      function validateInput(input, validChars) {
        let nonAllowedCharacters = [];

        for (let i = 0; i < input.length; i++) {
          if (!validChars.includes(input[i]) && !nonAllowedCharacters.includes(input[i])) {
            nonAllowedCharacters.push(input[i]);
          }
        }

        if (nonAllowedCharacters.length > 0) {
          const text = `Error: Characters ${JSON.stringify(nonAllowedCharacters)} are not allowed.`;
          textToSynthesizeErrorEl.innerText = text;
          textToSynthesizeErrorStreamEl.innerText = text;
          synthesizeBtnEl.disabled = true;
          return false;
        } else {
          const text = '&nbsp;';
          textToSynthesizeErrorEl.innerHTML = text;
          textToSynthesizeErrorStreamEl.innerHTML = text;
          synthesizeBtnEl.disabled = false;
          return true;
        }
      }

      function setAlignmentsTable(alignments) {
        alignmentsTableEl.style.display = 'block';
        const rowCount = alignmentsTableEl.rows.length;
        for (let i = 1; i < rowCount; i++) {
          alignmentsTableEl.deleteRow(1);
        }
        alignments.forEach((a) => {
          const row = alignmentsTableEl.insertRow(-1);
          row.style.verticalAlign = 'top';
          const word = row.insertCell(0);
          const start = row.insertCell(1);
          const end = row.insertCell(2);
          const phonemes = row.insertCell(3);

          word.innerHTML = `${a.word}`;
          start.innerHTML = `${a.startSec.toFixed(3)}`;
          end.innerHTML = `${a.endSec.toFixed(3)}`;
          const phonemesInnerHTML = a.phonemes.map(p => {
            return `<tr>
              <td style="text-align: left">${p.phoneme}</td>
              <td style="text-align: left">[${p.startSec.toFixed(3)} - ${p.endSec.toFixed(3)}s]</td>
            </tr>`;
          }).join('');
          phonemes.innerHTML = `
            <table>
              <colgroup>
                <col span="1" style="width: 25%" />
                <col span="1" style="width: 75%" />
              </colgroup>
              ${phonemesInnerHTML}
            </table>
          `;
        });
      }

      async function synthesize() {
        writeMessage('Synthesizing. Please wait...');
        try {
          textToSynthesizeEl.disabled = true;
          speechRateSliderEl.disabled = true;
          synthesizeBtnEl.disabled = true;
          controlBtnEl.disabled = true;
          downloadBtnEl.disabled = true;

          const text = textToSynthesizeEl.value;
          const speechRate = speechRateSliderEl.value;
          const result = await orca.synthesize(text, { speechRate });
          pcm = result.pcm;
          setAlignmentsTable(result.alignments);
          writeMessage('Synthesizing complete!');

          controlBtnEl.disabled = false;
          downloadBtnEl.disabled = false;
        } catch (err) {
          writeMessage(err);
        } finally {
          textToSynthesizeEl.disabled = false;
          speechRateSliderEl.disabled = false;
        }
      }

      function onAudioStop() {
        isPlaying = false;
        controlBtnEl.innerText = 'Play';
        textToSynthesizeEl.disabled = false;
        speechRateSliderEl.disabled = false;
      }

      textToSynthesizeEl.addEventListener('input', (e) => {
        onSynthesizeParamChange();
        if (orca !== null) {
          validateInput(e.target.value, orca.validCharacters);
        }
      });

      speechRateSliderEl.addEventListener('change', () => {
        onSynthesizeParamChange();
        speechRateDisplayEl.innerText = speechRateSliderEl.value;
      });

      synthesizeBtnEl.addEventListener('click', async () => await synthesize());

      controlBtnEl.addEventListener('click', () => {
        if (!isPlaying) {
          originalAudioSource = audioContext.createBufferSource();
          originalAudioSource.addEventListener('ended', onAudioStop);
          originalAudioSource.buffer = createBuffer(pcm);
          originalAudioSource.connect(originalAudioGain);
          originalAudioSource.start();

          isPlaying = true;
          controlBtnEl.innerText = 'Stop';
          textToSynthesizeEl.disabled = true;
          speechRateSliderEl.disabled = true;
          synthesizeBtnEl.disabled = true;
        } else {
          originalAudioSource.stop();
          onAudioStop();
        }
      });
    };

    async function startOrca(accessKey) {
      writeMessage('Orca is loading. Please wait...');
      try {
        document.getElementById('start-orca').disabled = true;

        orca = await OrcaWeb.OrcaWorker.create(
          accessKey,
          { base64: modelParams, forceWrite: true },
        );

        document.getElementById('choice-btns').style.display = 'block';
        writeMessage('Orca worker ready!');
      } catch (err) {
        writeMessage(err);
      }
    }

    function downloadDumpAudio() {
      let blob = new Blob([pcm]);
      let a = document.createElement('a');
      a.download = 'orca_speech_audio.pcm';
      a.href = window.URL.createObjectURL(blob);
      a.click();
    }

    function downloadStreamDumpAudio() {
      let blob = new Blob([new Int16Array(streamPcm)]);
      let a = document.createElement('a');
      a.download = 'orca_streaming_speech_audio.pcm';
      a.href = window.URL.createObjectURL(blob);
      a.click();
    }
  </script>
</head>
<body>
<h1>Orca Web Demo</h1>
<p>This demo uses Orca for Web to:</p>
<ol>
  <li>
    Create an instance of Orca with the model file provided.
  </li>
  <li>Convert text into speech audio data.</li>
</ol>
After entering the AccessKey, click the "Start Orca" button.
<hr />
<label for="accessKey"
>AccessKey obtained from
  <a href="https://console.picovoice.ai/">Picovoice Console</a>:</label
>
<input type="text" id="accessKey" name="accessKey" />
<input
  id="start-orca"
  type="button"
  value="Start Orca"
  onclick="startOrca(document.getElementById('accessKey').value)"
/>
<div id="choice-btns" style="display: none">
  <hr />
  Synthesize a live stream of text: <input
  id="choose-streaming-btn"
  type="button"
  value="Streaming Synthesis"
/>
  <br />
  <br />
  <b>OR</b>
  <br />
  <br />
  Synthesize a string of text in one call: <input
  id="choose-single-btn"
  type="button"
  value="Single Synthesis"
/>
  <hr />
</div>
<div id="streaming-synthesis" style="display: none">
  <hr />
  <label>
    Speech Rate: <span id="speech-rate-stream-display">1.0</span>
    <input
      id="speech-rate-stream"
      type="range"
      min="0.7"
      max="1.3"
      value="1"
      step="0.1"
    />
  </label>
  <br />
  <br />
  <input
    id="stream-open"
    type="button"
    value="Open Stream"
  />
  <br />
  <br />
  <label for="text-to-synthesize-stream">Text to synthesize</label>
  <br />
  <textarea id="text-to-synthesize-stream" rows="4" cols="50" maxlength="200" disabled></textarea>
  <div id="text-to-synthesize-stream-error">&nbsp;</div>
  <input
    id="stream-flush"
    type="button"
    value="Flush Stream"
    disabled
  />
  <button id="download-stream-btn" onclick="downloadStreamDumpAudio()" disabled>Download Audio</button>
</div>
<div id="single-synthesis" style="display: none">
  <hr />
  <label for="text-to-synthesize">Text to synthesize</label>
  <br />
  <textarea id="text-to-synthesize" rows="4" cols="50" maxlength="200">
</textarea>
  <div id="text-to-synthesize-error">&nbsp;</div>
  <label>
    Speech Rate: <span id="speech-rate-display">1.0</span>
    <input
      id="speech-rate"
      type="range"
      min="0.7"
      max="1.3"
      value="1"
      step="0.1"
    />
  </label>
  <br />
  <hr />
  <button id="synthesize-btn">
    Synthesize
  </button>
  <button id="control-btn" disabled>Play</button>
  <button id="download-btn" disabled onclick="downloadDumpAudio()">Download Audio</button>
</div>
<br />
<br />
<div id="status" style="white-space: pre"></div>
<br />
<table id="alignments-table" style="display: none">
  <colgroup>
    <col span="1" style="width: 20%" />
    <col span="1" style="width: 20%" />
    <col span="1" style="width: 20%" />
    <col span="1" style="width: 40%" />
  </colgroup>
  <tr>
    <th style="text-align: left">Word</th>
    <th style="text-align: left">Start time (s)</th>
    <th style="text-align: left">End time (s)</th>
    <th style="text-align: left">Phonemes</th>
  </tr>
</table>
</body>
</html>
